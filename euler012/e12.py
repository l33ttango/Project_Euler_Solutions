"""

Project Euler 12

The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28
36: 1, 2, 3, 4, 6, 9, 12, 18
45: 1, 3, 5, 9, 15
We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?

Solution = 76576500
Run time = 10.38737607

"""

"""
NOTES

The nth triangle number = 1 + 2 + 3 + ... + n = n * (n + 1) / 2

It can be shown that any number n that can be written as

n = p_1^a * p_2 ^ b * ... *p_m ^ k

where p_i is a unique prime, 
the total number of divisors of n can be written as 

(a + 1) * (b + 1) * ... * (k + 1)

Solution: 76576500
Runtime: 4.072973728179932 sec
"""

import math
import time

start = time.time()
def nth_triangle_number(n):
    return n * (n + 1) / 2

def primes_sieve(limit):
    limitn = limit + 1
    not_prime = [False] * limitn
    primes = []

    for i in range(2, limitn):
        if not_prime[i]:
            continue
        for f in range(i * 2, limitn, i):
            not_prime[f] = True

        primes.append(i)

    return primes


PRIMES = primes_sieve(2000000)
   
def find_number_of_divisors(num):
    """
    Returns the number of divisors of num    
    """
    divisors = 1
    original_number = num
    for i in PRIMES:
        if i > math.sqrt(num) + 1:
            return divisors

        ith_divisor_freq = 0        
        while num % i == 0:
            num = num / i
            ith_divisor_freq += 1
        divisors *= ith_divisor_freq + 1
        num = original_number


def first_triangular_with_more_than_n_divisors(num_divisors):
    """
    Returns first triangular number with more than num_divisor
    """
    for i in range(50000):
        triangular_num_i = nth_triangle_number(i)
        if find_number_of_divisors(triangular_num_i) >num_divisors:
            return triangular_num_i
    
    raise ValueError("Oops! You need to use a bigger xrange or PRIME range")
    
print (first_triangular_with_more_than_n_divisors(500))

end = time.time()
total_time = end - start
print (total_time)